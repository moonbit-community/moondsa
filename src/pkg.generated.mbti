// Generated using `moon info`, DON'T EDIT IT
package "ruifeng/moondsa"

import(
  "moonbitlang/core/random"
)

// Values
pub const CRHBYTES : Int = 64

pub const D : Int = 13

pub const N : Int = 256

pub const POLYT0_PACKEDBYTES : Int = 416

pub const POLYT1_PACKEDBYTES : Int = 320

pub const POLY_UNIFORM_NBLOCKS : UInt = 5

pub const Q : Int = 8380417

pub const SEEDBYTES : Int = 32

pub const SHAKE128_RATE : UInt = 168

pub const SHAKE256_RATE : UInt = 136

pub const STREAM128_BLOCKBYTES : UInt = 168

pub const STREAM256_BLOCKBYTES : UInt = 136

pub fn caddq(Int) -> Int

pub fn decompose(Int) -> (Int, Int)

pub let dilithium_context : DilithiumContext

pub fn dilithium_shake128_stream_init(KeccakState, Array[Byte], UInt16) -> Unit

pub fn dilithium_shake256_stream_init(KeccakState, Array[Byte], UInt16) -> Unit

pub fn inv_ntt_to_mont(Array[Int]) -> Unit

pub fn ite(Bool, Int, Int) -> Int

pub fn keccakf1600_statepermute(FixedArray[UInt64]) -> Unit

pub fn keypair_gen(Result[Array[Byte], @random.Rand]) -> (Array[Byte], Array[Byte])

pub fn load64(Array[Byte]) -> UInt64

pub fn make_hint(Int, Int) -> Byte

pub fn montgomery_reduce(Int64) -> Int

pub fn ntt(Array[Int]) -> Unit

pub fn pack_pk(Array[Byte], Polyveck) -> Array[Byte]

pub fn pack_sig(Array[Byte], Array[Byte]?, Polyvecl, Polyveck) -> Array[Byte]

pub fn pack_sk(Array[Byte], Array[Byte], Array[Byte], Polyveck, Polyvecl, Polyveck) -> Array[Byte]

pub fn polyvec_matrix_pointwise_montgomery(Polyveck, Array[Polyvecl], Polyvecl) -> Unit

pub fn power2round(Int) -> (Int, Int)

pub fn randombytes(@random.Rand, Int) -> Array[Byte]

pub fn reduce32(Int) -> Int

pub fn rej_eta(MutArrayView[Int], Int, Array[Byte], Int) -> UInt

pub fn rej_uniform(MutArrayView[Int], Int, Array[Byte], Int) -> Int

pub fn shake128_absorb(KeccakState, Array[Byte], UInt) -> Unit

pub fn shake128_finalize(KeccakState) -> Unit

pub fn shake128_squeezeblocks(MutArrayView[Byte], UInt, KeccakState) -> Unit

pub fn shake256(output~ : Array[Byte], UInt, input~ : Array[Byte], UInt) -> Unit

pub fn shake256_absorb(KeccakState, Array[Byte], UInt) -> Unit

pub fn shake256_absorb_once(KeccakState, Array[Byte], UInt) -> Unit

pub fn shake256_finalize(KeccakState) -> Unit

pub fn shake256_squeeze(MutArrayView[Byte], UInt, KeccakState) -> Unit

pub fn shake256_squeezeblocks(Array[Byte], UInt, KeccakState) -> Unit

pub fn sign(Array[Byte], Array[Byte]) -> Array[Byte]

pub fn store64(Array[Byte], UInt64) -> Unit

pub fn stream128_init(KeccakState, Array[Byte], UInt16) -> Unit

pub fn stream128_squeezeblocks(MutArrayView[Byte], UInt64, KeccakState) -> Unit

pub fn stream256_init(KeccakState, Array[Byte], UInt16) -> Unit

pub fn stream256_squeezeblocks(Array[Byte], UInt64, KeccakState) -> Unit

pub fn unpack_pk(Array[Byte]) -> (Array[Byte], Polyveck)

pub fn unpack_sig(Array[Byte]) -> Result[(Polyvecl, Polyveck, Array[Byte]), SignError]

pub fn unpack_sk(Array[Byte]) -> (Array[Byte], Array[Byte], Array[Byte], Polyveck, Polyvecl, Polyveck)

pub fn use_hint(Int, Byte) -> Int

pub fn verify(Array[Byte], Array[Byte], Array[Byte]) -> Result[Unit, SignError]

// Errors
type SignError

// Types and methods
type BigRandom
pub fn BigRandom::get_random(Array[Byte], Int) -> @random.Rand

type DilithiumContext
pub fn DilithiumContext::get_params_set(Self) -> ParameterSet
pub fn DilithiumContext::get_random(Self) -> @random.Rand
pub fn DilithiumContext::set_level(Self, SecurityLevel) -> Unit
pub fn DilithiumContext::set_random(Self, @random.Rand) -> Unit

pub struct KeccakState {
  s : FixedArray[UInt64]
  mut pos : UInt
}
pub fn KeccakState::init(Self) -> Unit
pub impl Default for KeccakState
pub impl Show for KeccakState

pub struct ParameterSet {
  k : Int
  l : Int
  eta : Int
  tau : Int
  beta : Int
  gamma1 : Int
  gamma2 : Int
  omega : Int
  publickey_bytes : Int
  polyeta_packedbytes : Int
  polyw1_packedbytes : Int
  polyz_packed_bytes : Int
  poly_uniform_gamma1_nblocks : UInt
  polyvech_packed_bytes : Int
  sign_bytes : Int
  level : SecurityLevel
  features : Map[String, String]
}

pub struct Poly {
  coeffs : Array[Int]
}
pub fn Poly::add(Self, Self) -> Unit
pub fn Poly::caddq(Self) -> Unit
pub fn Poly::challenge(Self, Array[Byte]) -> Unit
pub fn Poly::chknorm(Self, Int) -> Byte
pub fn Poly::copy(Self) -> Self
pub fn Poly::decompose(Self, Self) -> Unit
pub fn Poly::inv_ntt_to_mont(Self) -> Unit
pub fn Poly::make_hint(Self, Self, Self) -> Int
pub fn Poly::new() -> Self
pub fn Poly::ntt(Self) -> Unit
pub fn Poly::pack_eta(Self) -> Array[Byte]
pub fn Poly::pack_t0(Self) -> Array[Byte]
pub fn Poly::pack_t1(Self) -> Array[Byte]
pub fn Poly::pack_w1(Self) -> Array[Byte]
pub fn Poly::pack_z(Self) -> Array[Byte]
pub fn Poly::pointwise_montgomery(Self, Self, Self) -> Unit
pub fn Poly::poly_uniform_eta(Self, Array[Byte], UInt16) -> Unit
pub fn Poly::power2round(Self, Self) -> Unit
pub fn Poly::reduce(Self) -> Unit
pub fn Poly::shiftl(Self) -> Unit
pub fn Poly::sub(Self, Self) -> Unit
pub fn Poly::uniform(Self, Array[Byte], UInt16) -> Unit
pub fn Poly::uniform_gamma1(Self, Array[Byte], UInt16) -> Unit
pub fn Poly::unpack_eta(Self, Array[Byte]) -> Unit
pub fn Poly::unpack_t0(Self, Array[Byte]) -> Unit
pub fn Poly::unpack_t1(Self, Array[Byte]) -> Unit
pub fn Poly::unpack_z(Self, Array[Byte]) -> Unit
pub fn Poly::use_hint(Self, Self) -> Unit
pub impl Show for Poly

pub struct Polyveck {
  vec : Array[Poly]
}
pub fn Polyveck::add(Self, Self) -> Unit
pub fn Polyveck::caddq(Self) -> Unit
pub fn Polyveck::chknorm(Self, Int) -> Byte
pub fn Polyveck::copy(Self) -> Self
pub fn Polyveck::decompose(Self, Self) -> Unit
pub fn Polyveck::invntt_tomont(Self) -> Unit
pub fn Polyveck::make_hint(Self, Self, Self) -> Int
pub fn Polyveck::ntt(Self) -> Unit
pub fn Polyveck::pack_w1(Self, Array[Byte]) -> Unit
pub fn Polyveck::pointwise_poly_montgomery(Self, Poly, Self) -> Unit
pub fn Polyveck::power2round(Self, Self) -> Unit
pub fn Polyveck::reduce(Self) -> Unit
pub fn Polyveck::shiftl(Self) -> Unit
pub fn Polyveck::sub(Self, Self) -> Unit
pub fn Polyveck::uniform_eta(Self, Array[Byte], UInt16) -> Unit
pub fn Polyveck::use_hint(Self, Self) -> Unit
pub impl Default for Polyveck
pub impl Show for Polyveck

pub struct Polyvecl {
  vec : Array[Poly]
}
pub fn Polyvecl::add(Self, Self) -> Unit
pub fn Polyvecl::chknorm(Self, Int) -> Byte
pub fn Polyvecl::copy(Self) -> Self
pub fn Polyvecl::invntt_tomont(Self) -> Unit
pub fn Polyvecl::matrix_expand(Array[Self], Array[Byte]) -> Unit
pub fn Polyvecl::ntt(Self) -> Unit
pub fn Polyvecl::pointwise_acc_montgomery(Poly, Self, Self) -> Unit
pub fn Polyvecl::pointwise_poly_montgomery(Self, Poly, Self) -> Unit
pub fn Polyvecl::reduce(Self) -> Unit
pub fn Polyvecl::uniform_eta(Self, Array[Byte], UInt16) -> Unit
pub fn Polyvecl::uniform_gamma1(Self, Array[Byte], UInt16) -> Unit
pub impl Default for Polyvecl
pub impl Show for Polyvecl

pub(all) enum SecurityLevel {
  Dilithium2
  Dilithium3
  Dilithium5
}

// Type aliases

// Traits

